<!DOCTYPE html>
<html lang="zh_CN">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="theme-color" content="#494f5c">
	<meta name="msapplication-TileColor" content="#494f5c">
<meta itemprop="name" content="Python实现对大文件的增量读取">
<meta itemprop="description" content="一、背景 前段时间在做算法测试，需要对源于日志的数据进行分析才能获取到结果；日志文件较大，所以需要获取数据的变化曲线，增量读取是最好的方式。
 网上有很多人的技术博客都是写的用for循环readline以及一个计数器去增量读取，假如文件很大，遍历一次太久。而且对于很多大文件的增量读取，如果遍历每一行比对历史记录的输出或者全都加载到内存通过历史记录的索引查找，是非常浪费资源的。
获取文件句柄的基本理论中就包含指针操作。linux的文件描述符的struct里有一个f_pos的这么个属性，里面存着文件当前读取位置，通过这个东东经过vfs的一系列映射就会得到硬盘存储的位置了，所以很直接，很快。
在Python中的读取文件的方法也有类似的属性。
 二、具体实现方法 Python中相关的方法的核心函数如下：
   函数 作用     tell() 返回文件当前位置   seek() 从指定位置开始读取信息    其中seek()有三种模式：
 f.seek(p,0)移动当文件第p个字节处，绝对位置 f.seek(p,1)移动到相对于当前位置之后的p个字节 f.seek(p,2)移动到相对文章尾之后的p个字节  参考代码：
#!/usr/bin/python fd=open(&#34;test.txt&#34;,&#39;r&#39;) #获得一个句柄 for i in xrange(1,3): #读取三行数据 fd.readline() label=fd.tell() #记录读取到的位置 fd.close() #关闭文件 #再次阅读文件 fd=open(&#34;test.txt&#34;,&#39;r&#39;) #获得一个句柄 fd.seek(label,0)# 把文件读取指针移动到之前记录的位置 fd.readline() #接着上次的位置继续向下读取 三、拓展 1、如何知道这个大文件行数以及变化？  遍历&rsquo;\n&rsquo;字符 开始时就在for循环中对fd.readline()计数，变化的部分(用上文说的seek、tell函数)再用for循环fd.readline()进行统计  2、如何避免文件读取时，内存溢出  可以通过read函数的chunk关键字来指定每次读取数据大小 使用生成器确保只有在数据被调用时候才会生成  具体方法封装如下：
def read_in_chunks(file_path, chunk=100 * 100): # 通过chunk指定每次读取文件的大小防止内存占用过大 file_object = open(file_path, &#34;r&#34;) while True: data = file_object.">


<meta itemprop="datePublished" content="2019-10-08T16:30:58&#43;08:00" />
<meta itemprop="dateModified" content="2019-10-08T16:30:58&#43;08:00" />
<meta itemprop="wordCount" content="71">



<meta itemprop="keywords" content="python," />
<meta property="og:title" content="Python实现对大文件的增量读取" />
<meta property="og:description" content="一、背景 前段时间在做算法测试，需要对源于日志的数据进行分析才能获取到结果；日志文件较大，所以需要获取数据的变化曲线，增量读取是最好的方式。
 网上有很多人的技术博客都是写的用for循环readline以及一个计数器去增量读取，假如文件很大，遍历一次太久。而且对于很多大文件的增量读取，如果遍历每一行比对历史记录的输出或者全都加载到内存通过历史记录的索引查找，是非常浪费资源的。
获取文件句柄的基本理论中就包含指针操作。linux的文件描述符的struct里有一个f_pos的这么个属性，里面存着文件当前读取位置，通过这个东东经过vfs的一系列映射就会得到硬盘存储的位置了，所以很直接，很快。
在Python中的读取文件的方法也有类似的属性。
 二、具体实现方法 Python中相关的方法的核心函数如下：
   函数 作用     tell() 返回文件当前位置   seek() 从指定位置开始读取信息    其中seek()有三种模式：
 f.seek(p,0)移动当文件第p个字节处，绝对位置 f.seek(p,1)移动到相对于当前位置之后的p个字节 f.seek(p,2)移动到相对文章尾之后的p个字节  参考代码：
#!/usr/bin/python fd=open(&#34;test.txt&#34;,&#39;r&#39;) #获得一个句柄 for i in xrange(1,3): #读取三行数据 fd.readline() label=fd.tell() #记录读取到的位置 fd.close() #关闭文件 #再次阅读文件 fd=open(&#34;test.txt&#34;,&#39;r&#39;) #获得一个句柄 fd.seek(label,0)# 把文件读取指针移动到之前记录的位置 fd.readline() #接着上次的位置继续向下读取 三、拓展 1、如何知道这个大文件行数以及变化？  遍历&rsquo;\n&rsquo;字符 开始时就在for循环中对fd.readline()计数，变化的部分(用上文说的seek、tell函数)再用for循环fd.readline()进行统计  2、如何避免文件读取时，内存溢出  可以通过read函数的chunk关键字来指定每次读取数据大小 使用生成器确保只有在数据被调用时候才会生成  具体方法封装如下：
def read_in_chunks(file_path, chunk=100 * 100): # 通过chunk指定每次读取文件的大小防止内存占用过大 file_object = open(file_path, &#34;r&#34;) while True: data = file_object." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ycooperz.github.io/post/blog/" />
<meta property="article:published_time" content="2019-10-08T16:30:58+08:00" />
<meta property="article:modified_time" content="2019-10-08T16:30:58+08:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Python实现对大文件的增量读取"/>
<meta name="twitter:description" content="一、背景 前段时间在做算法测试，需要对源于日志的数据进行分析才能获取到结果；日志文件较大，所以需要获取数据的变化曲线，增量读取是最好的方式。
 网上有很多人的技术博客都是写的用for循环readline以及一个计数器去增量读取，假如文件很大，遍历一次太久。而且对于很多大文件的增量读取，如果遍历每一行比对历史记录的输出或者全都加载到内存通过历史记录的索引查找，是非常浪费资源的。
获取文件句柄的基本理论中就包含指针操作。linux的文件描述符的struct里有一个f_pos的这么个属性，里面存着文件当前读取位置，通过这个东东经过vfs的一系列映射就会得到硬盘存储的位置了，所以很直接，很快。
在Python中的读取文件的方法也有类似的属性。
 二、具体实现方法 Python中相关的方法的核心函数如下：
   函数 作用     tell() 返回文件当前位置   seek() 从指定位置开始读取信息    其中seek()有三种模式：
 f.seek(p,0)移动当文件第p个字节处，绝对位置 f.seek(p,1)移动到相对于当前位置之后的p个字节 f.seek(p,2)移动到相对文章尾之后的p个字节  参考代码：
#!/usr/bin/python fd=open(&#34;test.txt&#34;,&#39;r&#39;) #获得一个句柄 for i in xrange(1,3): #读取三行数据 fd.readline() label=fd.tell() #记录读取到的位置 fd.close() #关闭文件 #再次阅读文件 fd=open(&#34;test.txt&#34;,&#39;r&#39;) #获得一个句柄 fd.seek(label,0)# 把文件读取指针移动到之前记录的位置 fd.readline() #接着上次的位置继续向下读取 三、拓展 1、如何知道这个大文件行数以及变化？  遍历&rsquo;\n&rsquo;字符 开始时就在for循环中对fd.readline()计数，变化的部分(用上文说的seek、tell函数)再用for循环fd.readline()进行统计  2、如何避免文件读取时，内存溢出  可以通过read函数的chunk关键字来指定每次读取数据大小 使用生成器确保只有在数据被调用时候才会生成  具体方法封装如下：
def read_in_chunks(file_path, chunk=100 * 100): # 通过chunk指定每次读取文件的大小防止内存占用过大 file_object = open(file_path, &#34;r&#34;) while True: data = file_object."/>

	<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
	<link rel="manifest" href="/site.webmanifest">
	<link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
	<link rel="shortcut icon" href="/favicon.ico">

	<title>Python实现对大文件的增量读取</title>
	<link rel="stylesheet" href="https://ycooperz.github.io/css/style.min.5ee5e7976cd09872c64e40a582206543f6aa38c69a8c43898aadc70040344b92.css" integrity="sha256-XuXnl2zQmHLGTkClgiBlQ/aqOMaajEOJiq3HAEA0S5I=" crossorigin="anonymous">
	
</head>

<body id="page">
	
	<header id="site-header" class="animated slideInUp faster">
		<div class="hdr-wrapper section-inner">
			<div class="hdr-left">
				<div class="site-branding">
					<a href="https://ycooperz.github.io">锄禾博客</a>
				</div>
				<nav class="site-nav hide-in-mobile">
					
				<a href="https://ycooperz.github.io/posts/">文章</a>
				<a href="https://ycooperz.github.io/about-hugo/">关于</a>

				</nav>
			</div>
			<div class="hdr-right hdr-icons">
				<span class="hdr-social hide-in-mobile"><a href="mailto:1239559919@qq.com" target="_blank" rel="noopener me" title="Mail"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></span><button id="menu-btn" class="hdr-btn" title="Menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></button>
			</div>
		</div>
	</header>
	<div id="mobile-menu" class="animated fast">
		<ul>
			<li><a href="https://ycooperz.github.io/posts/">文章</a></li>
			<li><a href="https://ycooperz.github.io/about-hugo/">关于</a></li>
		</ul>
	</div>


	<main class="site-main section-inner thin animated fadeIn faster">
		<h1>Python实现对大文件的增量读取</h1>
		<div class="content">
			

<h3 id="一-背景">一、背景<a href="#一-背景" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>前段时间在做算法测试，需要对源于日志的数据进行分析才能获取到结果；日志文件较大，所以需要获取数据的变化曲线，增量读取是最好的方式。</p>

<p><img src="https://img2018.cnblogs.com/blog/1172048/201812/1172048-20181208160232586-19406433.png" alt="" /></p>

<blockquote>
<p>网上有很多人的技术博客都是写的用for循环readline以及一个计数器去增量读取，假如文件很大，遍历一次太久。而且对于很多大文件的增量读取，如果遍历每一行比对历史记录的输出或者全都加载到内存通过历史记录的索引查找，是非常浪费资源的。</p>

<p>获取文件句柄的基本理论中就包含指针操作。linux的文件描述符的struct里有一个f_pos的这么个属性，里面存着文件当前读取位置，通过这个东东经过vfs的一系列映射就会得到硬盘存储的位置了，所以很直接，很快。</p>

<p>在Python中的读取文件的方法也有类似的属性。</p>
</blockquote>

<h3 id="二-具体实现方法">二、具体实现方法<a href="#二-具体实现方法" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<p>Python中相关的方法的核心函数如下：</p>

<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">tell()</td>
<td align="center">返回文件当前位置</td>
</tr>

<tr>
<td align="center">seek()</td>
<td align="center">从指定位置开始读取信息</td>
</tr>
</tbody>
</table>

<p>其中seek()有三种模式：</p>

<ul>
<li>f.seek(p,0)移动当文件第p个字节处，绝对位置</li>
<li>f.seek(p,1)移动到相对于当前位置之后的p个字节</li>
<li>f.seek(p,2)移动到相对文章尾之后的p个字节</li>
</ul>

<p>参考代码：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="ch">#!/usr/bin/python</span>
<span class="n">fd</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="s2">&#34;test.txt&#34;</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="c1">#获得一个句柄</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span> <span class="c1">#读取三行数据</span>
    <span class="n">fd</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="n">label</span><span class="o">=</span><span class="n">fd</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="c1">#记录读取到的位置</span>
<span class="n">fd</span><span class="o">.</span><span class="n">close</span><span class="p">()</span> <span class="c1">#关闭文件</span>
<span class="c1">#再次阅读文件</span>
<span class="n">fd</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="s2">&#34;test.txt&#34;</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="c1">#获得一个句柄</span>
<span class="n">fd</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="c1"># 把文件读取指针移动到之前记录的位置</span>
<span class="n">fd</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span> <span class="c1">#接着上次的位置继续向下读取</span></code></pre></div>
<h3 id="三-拓展">三、拓展<a href="#三-拓展" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h3>

<h5 id="1-如何知道这个大文件行数以及变化">1、如何知道这个大文件行数以及变化？<a href="#1-如何知道这个大文件行数以及变化" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>

<ul>
<li>遍历&rsquo;\n&rsquo;字符</li>
<li>开始时就在for循环中对fd.readline()计数，变化的部分(用上文说的seek、tell函数)再用for循环fd.readline()进行统计</li>
</ul>

<h5 id="2-如何避免文件读取时-内存溢出">2、如何避免文件读取时，内存溢出<a href="#2-如何避免文件读取时-内存溢出" class="anchor" aria-hidden="true"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg></a></h5>

<ul>
<li>可以通过read函数的chunk关键字来指定每次读取数据大小</li>
<li>使用生成器确保只有在数据被调用时候才会生成</li>
</ul>

<p>具体方法封装如下：</p>
<div class="highlight"><pre class="chroma"><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">read_in_chunks</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span>  <span class="n">chunk</span><span class="o">=</span><span class="mi">100</span> <span class="o">*</span> <span class="mi">100</span><span class="p">):</span>  <span class="c1"># 通过chunk指定每次读取文件的大小防止内存占用过大</span>
    <span class="n">file_object</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_path</span><span class="p">,</span> <span class="s2">&#34;r&#34;</span><span class="p">)</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">file_object</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">file_object</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">break</span>
        <span class="c1"># 使用generator（生成器）使数据只有在被使用时才会迭代时占用内存</span>
        <span class="k">yield</span> <span class="n">data</span></code></pre></div>
		</div>
	</main>

	<footer id="site-footer" class="section-inner thin animated fadeIn faster">
		<p>&copy; 2019 <a href="https://ycooperz.github.io">锄禾</a> &#183; <a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></p>
		<p>
			Made with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> &#183; Theme <a href="https://github.com/Track3/hermit" target="_blank" rel="noopener">Hermit</a> &#183; <a href="https://ycooperz.github.io/posts/index.xml" target="_blank" title="rss"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-rss"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg></a>
		</p>
	</footer>



	<script src="https://ycooperz.github.io/js/bundle.min.4a9a0ac3d2217822c7865b4161e6c2a71de1d70492264337755427898dd718f6.js" integrity="sha256-SpoKw9IheCLHhltBYebCpx3h1wSSJkM3dVQniY3XGPY=" crossorigin="anonymous"></script>
	

</body>

</html>
